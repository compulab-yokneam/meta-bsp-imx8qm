From 945777470783765523ab02d577707f166da091e0 Mon Sep 17 00:00:00 2001
From: Ilya Ledvich <ilya@compulab.co.il>
Date: Wed, 3 Mar 2021 11:24:58 +0200
Subject: [PATCH 1/3] arm: imx8qm: cl-som-imx8max: add initial board support

Add basic support for the Compulab CL-SOM-iMX8MAX module.
The module is based on the NXP i.MX8QM SoC.
Currently supported features:
 - Debug UART - UART0
 - Ethernet ports - FEC1
 - uSDHC 1 - eMMC
 - uSDHC 2 - SD card
 - USB OTG 3

Signed-off-by: Ilya Ledvich <ilya@compulab.co.il>
---
 arch/arm/dts/Makefile                         |   1 +
 arch/arm/dts/cl-som-imx8max-u-boot.dtsi       | 262 ++++++++++
 arch/arm/dts/cl-som-imx8max.dts               | 341 +++++++++++++
 arch/arm/mach-imx/imx8/Kconfig                |   6 +
 board/compulab/cl-som-imx8max/Kconfig         |  14 +
 board/compulab/cl-som-imx8max/MAINTAINERS     |   6 +
 board/compulab/cl-som-imx8max/Makefile        |   8 +
 board/compulab/cl-som-imx8max/README          |  54 ++
 .../compulab/cl-som-imx8max/cl-som-imx8max.c  | 480 ++++++++++++++++++
 board/compulab/cl-som-imx8max/imximage.cfg    |  19 +
 board/compulab/cl-som-imx8max/spl.c           |  65 +++
 board/compulab/cl-som-imx8max/spl.c.bak       |  65 +++
 .../cl-som-imx8max/uboot-container.cfg        |  13 +
 configs/cl_som_imx8max_defconfig              | 195 +++++++
 include/configs/cl-som-imx8max.h              | 375 ++++++++++++++
 include/linux/sizes.h                         |   2 +
 16 files changed, 1906 insertions(+)
 create mode 100644 arch/arm/dts/cl-som-imx8max-u-boot.dtsi
 create mode 100644 arch/arm/dts/cl-som-imx8max.dts
 create mode 100644 board/compulab/cl-som-imx8max/Kconfig
 create mode 100644 board/compulab/cl-som-imx8max/MAINTAINERS
 create mode 100644 board/compulab/cl-som-imx8max/Makefile
 create mode 100644 board/compulab/cl-som-imx8max/README
 create mode 100644 board/compulab/cl-som-imx8max/cl-som-imx8max.c
 create mode 100644 board/compulab/cl-som-imx8max/imximage.cfg
 create mode 100644 board/compulab/cl-som-imx8max/spl.c
 create mode 100644 board/compulab/cl-som-imx8max/spl.c.bak
 create mode 100644 board/compulab/cl-som-imx8max/uboot-container.cfg
 create mode 100644 configs/cl_som_imx8max_defconfig
 create mode 100644 include/configs/cl-som-imx8max.h

diff --git a/arch/arm/dts/Makefile b/arch/arm/dts/Makefile
index 0d24acd457..2af5506497 100644
--- a/arch/arm/dts/Makefile
+++ b/arch/arm/dts/Makefile
@@ -778,6 +778,7 @@ dtb-$(CONFIG_ARCH_IMX8) += \
 	fsl-imx8dxl-evk.dtb \
 	fsl-imx8dxl-evk-lcdif.dtb \
 	fsl-imx8dxl-ddr3-evk.dtb \
+	cl-som-imx8max.dtb \
 	imx8-deneb.dtb \
 	imx8-giedi.dtb
 
diff --git a/arch/arm/dts/cl-som-imx8max-u-boot.dtsi b/arch/arm/dts/cl-som-imx8max-u-boot.dtsi
new file mode 100644
index 0000000000..f8ef50e22c
--- /dev/null
+++ b/arch/arm/dts/cl-som-imx8max-u-boot.dtsi
@@ -0,0 +1,262 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2021 Compulab
+ */
+
+/ {
+
+	aliases {
+		usbhost1 = &usbh3;
+		usbgadget0 = &usbg1;
+	};
+
+	usbh3: usbh3 {
+		compatible = "Cadence,usb3-host";
+		dr_mode = "host";
+		cdns3,usb = <&usbotg3>;
+		status = "okay";
+	};
+
+	usbg1: usbg1 {
+		compatible = "fsl,imx27-usb-gadget";
+		dr_mode = "peripheral";
+		chipidea,usb = <&usbotg1>;
+		status = "okay";
+		u-boot,dm-spl;
+	};
+};
+
+&{/imx8qm-pm} {
+
+	u-boot,dm-spl;
+};
+
+&mu {
+	u-boot,dm-spl;
+};
+
+&clk {
+	u-boot,dm-spl;
+};
+
+&iomuxc {
+	u-boot,dm-spl;
+};
+
+&{/regulators} {
+	u-boot,dm-spl;
+};
+
+&{/leds} {
+	u-boot,dm-spl;
+};
+
+&{/mu@5d1c0000/iomuxc/cl-som-imx8max} {
+	u-boot,dm-spl;
+};
+
+&pinctrl_usdhc2_gpio {
+	u-boot,dm-spl;
+};
+
+&pinctrl_usdhc2 {
+	u-boot,dm-spl;
+};
+
+&pinctrl_lpuart0 {
+	u-boot,dm-spl;
+};
+
+&pinctrl_usdhc1 {
+	u-boot,dm-spl;
+};
+
+&pinctrl_flexspi0 {
+	u-boot,dm-spl;
+};
+
+&pinctrl_usbh1 {
+	u-boot,dm-spl;
+};
+
+&pd_lsio {
+	u-boot,dm-spl;
+};
+
+&pd_lsio_gpio0 {
+	u-boot,dm-spl;
+};
+
+&pd_lsio_gpio1 {
+	u-boot,dm-spl;
+};
+
+&pd_lsio_gpio2 {
+	u-boot,dm-spl;
+};
+
+&pd_lsio_gpio3 {
+	u-boot,dm-spl;
+};
+
+&pd_lsio_gpio4 {
+	u-boot,dm-spl;
+};
+
+&pd_lsio_gpio5 {
+	u-boot,dm-spl;
+};
+
+&pd_lsio_gpio6 {
+	u-boot,dm-spl;
+};
+
+&pd_lsio_gpio7 {
+	u-boot,dm-spl;
+};
+
+&pd_lsio_flexspi0 {
+	u-boot,dm-spl;
+};
+
+&pd_conn {
+	u-boot,dm-spl;
+};
+
+&pd_conn_sdch0 {
+	u-boot,dm-spl;
+};
+
+&pd_conn_sdch1 {
+	u-boot,dm-spl;
+};
+
+&pd_conn_sdch2 {
+	u-boot,dm-spl;
+};
+
+&pd_dma {
+	u-boot,dm-spl;
+};
+
+&pd_dma_lpuart0 {
+	u-boot,dm-spl;
+};
+
+&pd_dma_lpi2c2 {
+	u-boot,dm-spl;
+};
+
+&pd_conn_usbotg0 {
+	u-boot,dm-spl;
+};
+
+&pd_conn_usbotg0_phy {
+	u-boot,dm-spl;
+};
+
+&pd_conn_usb2 {
+	u-boot,dm-spl;
+};
+
+&pd_conn_usb2_phy {
+	u-boot,dm-spl;
+};
+
+&pd_conn_usbh1 {
+	u-boot,dm-spl;
+};
+
+
+&gpio0 {
+	u-boot,dm-spl;
+};
+
+&gpio1 {
+	u-boot,dm-spl;
+};
+
+&gpio2 {
+	u-boot,dm-spl;
+};
+
+&gpio3 {
+	u-boot,dm-spl;
+};
+
+&gpio4 {
+	u-boot,dm-spl;
+};
+
+&gpio5 {
+	u-boot,dm-spl;
+};
+
+&gpio6 {
+	u-boot,dm-spl;
+};
+
+&gpio7 {
+	u-boot,dm-spl;
+};
+
+&lpuart0 {
+	u-boot,dm-spl;
+};
+
+&usbmisc1 {
+	u-boot,dm-spl;
+};
+
+&usbphy1 {
+	u-boot,dm-spl;
+};
+
+&usbotg1 {
+	phys = <&usbphy1>;
+	u-boot,dm-spl;
+};
+
+&usbh1 {
+	phys = <&usbphynop2>;
+	u-boot,dm-spl;
+};
+
+&usbotg3 {
+	phys = <&usbphynop1>;
+	u-boot,dm-spl;
+};
+
+&usbphynop1 {
+	compatible = "cdns,usb3-phy";
+	reg = <0x0 0x5B160000 0x0 0x40000>;
+	#phy-cells = <0>;
+	u-boot,dm-spl;
+};
+
+&usbphynop2 {
+	u-boot,dm-spl;
+};
+
+&usdhc1 {
+	u-boot,dm-spl;
+	mmc-hs400-1_8v;
+};
+
+&usdhc2 {
+	u-boot,dm-spl;
+	sd-uhs-sdr104;
+	sd-uhs-ddr50;
+};
+
+&flexspi0 {
+	u-boot,dm-spl;
+};
+
+&flash0 {
+	u-boot,dm-spl;
+};
+
+&wu {
+	u-boot,dm-spl;
+};
diff --git a/arch/arm/dts/cl-som-imx8max.dts b/arch/arm/dts/cl-som-imx8max.dts
new file mode 100644
index 0000000000..fd90ae02d5
--- /dev/null
+++ b/arch/arm/dts/cl-som-imx8max.dts
@@ -0,0 +1,341 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2017-2018 NXP
+ */
+
+/dts-v1/;
+
+#include "fsl-imx8qm.dtsi"
+
+/ {
+	model = "Compulab CL-SOM-iMX8MAX";
+	compatible = "cl-som-imx8max", "fsl,imx8qm-mek", "fsl,imx8qm";
+
+	aliases {
+	};
+
+	chosen {
+		bootargs = "console=ttyLP0,115200 earlycon";
+		stdout-path = &lpuart0;
+	};
+
+	leds {
+		compatible = "gpio-leds";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_gpio_led>;
+
+		system-status {
+			gpios = <&gpio3 23 0>;
+			label = "status";
+			default-state = "on";
+		};
+	};
+
+	regulators {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <0>;
+	};
+};
+
+&iomuxc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hog>;
+
+	cl-som-imx8max {
+		pinctrl_hog: hoggrp {
+			fsl,pins = <
+				SC_P_SIM0_CLK_LSIO_GPIO0_IO00			0x06000060
+				SC_P_SIM0_IO_LSIO_GPIO0_IO02			0x06000060
+				SC_P_SIM0_RST_LSIO_GPIO0_IO01			0x06000060
+				SC_P_ADC_IN6_LSIO_GPIO3_IO24			0x06000021
+				SC_P_ESAI1_TX5_RX0_LSIO_GPIO2_IO13		0x06000060 /* USB_OTG1_MUX_SEL */
+				SC_P_PCIE_CTRL0_PERST_B_LSIO_GPIO4_IO29		0x06000020
+			>;
+		};
+
+		pinctrl_gpio_led: gpioledgrp {
+			fsl,pins = <
+				SC_P_ADC_IN5_LSIO_GPIO3_IO23			0x06000020
+			>;
+		};
+
+		pinctrl_fec1: fec1grp {
+			fsl,pins = <
+				SC_P_COMP_CTL_GPIO_1V8_3V3_ENET_ENETB_PAD	0x000014a0
+				SC_P_ENET0_MDC_CONN_ENET0_MDC			0x06000020
+				SC_P_ENET0_MDIO_CONN_ENET0_MDIO			0x06000020
+				SC_P_ENET0_RGMII_TX_CTL_CONN_ENET0_RGMII_TX_CTL	0x00000061
+				SC_P_ENET0_RGMII_TXC_CONN_ENET0_RGMII_TXC	0x00000061
+				SC_P_ENET0_RGMII_TXD0_CONN_ENET0_RGMII_TXD0	0x00000061
+				SC_P_ENET0_RGMII_TXD1_CONN_ENET0_RGMII_TXD1	0x00000061
+				SC_P_ENET0_RGMII_TXD2_CONN_ENET0_RGMII_TXD2	0x00000061
+				SC_P_ENET0_RGMII_TXD3_CONN_ENET0_RGMII_TXD3	0x00000061
+				SC_P_ENET0_RGMII_RXC_CONN_ENET0_RGMII_RXC	0x00000061
+				SC_P_ENET0_RGMII_RX_CTL_CONN_ENET0_RGMII_RX_CTL	0x00000061
+				SC_P_ENET0_RGMII_RXD0_CONN_ENET0_RGMII_RXD0	0x00000061
+				SC_P_ENET0_RGMII_RXD1_CONN_ENET0_RGMII_RXD1	0x00000061
+				SC_P_ENET0_RGMII_RXD2_CONN_ENET0_RGMII_RXD2	0x00000061
+				SC_P_ENET0_RGMII_RXD3_CONN_ENET0_RGMII_RXD3	0x00000061
+				SC_P_MLB_CLK_LSIO_GPIO3_IO27			0x06000020
+			>;
+		};
+
+		pinctrl_fec2: fec2grp {
+			fsl,pins = <
+				SC_P_COMP_CTL_GPIO_1V8_3V3_ENET_ENETA_PAD	0x000014a0
+				SC_P_ENET1_RGMII_TX_CTL_CONN_ENET1_RGMII_TX_CTL	0x00000060
+				SC_P_ENET1_RGMII_TXC_CONN_ENET1_RGMII_TXC	0x00000060
+				SC_P_ENET1_RGMII_TXD0_CONN_ENET1_RGMII_TXD0	0x00000060
+				SC_P_ENET1_RGMII_TXD1_CONN_ENET1_RGMII_TXD1	0x00000060
+				SC_P_ENET1_RGMII_TXD2_CONN_ENET1_RGMII_TXD2	0x00000060
+				SC_P_ENET1_RGMII_TXD3_CONN_ENET1_RGMII_TXD3	0x00000060
+				SC_P_ENET1_RGMII_RXC_CONN_ENET1_RGMII_RXC	0x00000060
+				SC_P_ENET1_RGMII_RX_CTL_CONN_ENET1_RGMII_RX_CTL	0x00000060
+				SC_P_ENET1_RGMII_RXD0_CONN_ENET1_RGMII_RXD0	0x00000060
+				SC_P_ENET1_RGMII_RXD1_CONN_ENET1_RGMII_RXD1	0x00000060
+				SC_P_ENET1_RGMII_RXD2_CONN_ENET1_RGMII_RXD2	0x00000060
+				SC_P_ENET1_RGMII_RXD3_CONN_ENET1_RGMII_RXD3	0x00000060
+				SC_P_MLB_DATA_LSIO_GPIO3_IO28			0x06000020
+			>;
+		};
+
+		pinctrl_flexspi0: flexspi0grp {
+			fsl,pins = <
+				SC_P_QSPI0A_DATA0_LSIO_QSPI0A_DATA0	0x06000021
+				SC_P_QSPI0A_DATA1_LSIO_QSPI0A_DATA1	0x06000021
+				SC_P_QSPI0A_DATA2_LSIO_QSPI0A_DATA2	0x06000021
+				SC_P_QSPI0A_DATA3_LSIO_QSPI0A_DATA3	0x06000021
+				SC_P_QSPI0A_DQS_LSIO_QSPI0A_DQS		0x06000021
+				SC_P_QSPI0A_SS0_B_LSIO_QSPI0A_SS0_B	0x06000021
+				SC_P_QSPI0A_SS1_B_LSIO_QSPI0A_SS1_B	0x06000021
+				SC_P_QSPI0A_SCLK_LSIO_QSPI0A_SCLK	0x06000021
+				SC_P_QSPI0B_SCLK_LSIO_QSPI0B_SCLK	0x06000021
+				SC_P_QSPI0B_DATA0_LSIO_QSPI0B_DATA0	0x06000021
+				SC_P_QSPI0B_DATA1_LSIO_QSPI0B_DATA1	0x06000021
+				SC_P_QSPI0B_DATA2_LSIO_QSPI0B_DATA2	0x06000021
+				SC_P_QSPI0B_DATA3_LSIO_QSPI0B_DATA3	0x06000021
+				SC_P_QSPI0B_DQS_LSIO_QSPI0B_DQS		0x06000021
+				SC_P_QSPI0B_SS0_B_LSIO_QSPI0B_SS0_B	0x06000021
+				SC_P_QSPI0B_SS1_B_LSIO_QSPI0B_SS1_B	0x06000021
+			>;
+		};
+
+		pinctrl_lpuart0: lpuart0grp {
+			fsl,pins = <
+				SC_P_UART0_RX_DMA_UART0_RX		0x06000020
+				SC_P_UART0_TX_DMA_UART0_TX		0x06000020
+			>;
+		};
+
+		pinctrl_usbh1: usbh1grp {
+			fsl,pins = <
+				SC_P_USB_HSIC0_DATA_CONN_USB_HSIC0_DATA		0xc60000d5
+				SC_P_USB_HSIC0_STROBE_CONN_USB_HSIC0_STROBE	0xc60000c5
+			>;
+		};
+
+		pinctrl_usbotg1: usbotg1 {
+			fsl,pins = <
+				SC_P_USB_SS3_TC0_CONN_USB_OTG1_PWR		0x00000021
+			>;
+		};
+
+		pinctrl_usdhc1: usdhc1grp {
+			fsl,pins = <
+				SC_P_EMMC0_CLK_CONN_EMMC0_CLK		0x06000041
+				SC_P_EMMC0_CMD_CONN_EMMC0_CMD		0x00000021
+				SC_P_EMMC0_DATA0_CONN_EMMC0_DATA0	0x00000021
+				SC_P_EMMC0_DATA1_CONN_EMMC0_DATA1	0x00000021
+				SC_P_EMMC0_DATA2_CONN_EMMC0_DATA2	0x00000021
+				SC_P_EMMC0_DATA3_CONN_EMMC0_DATA3	0x00000021
+				SC_P_EMMC0_DATA4_CONN_EMMC0_DATA4	0x00000021
+				SC_P_EMMC0_DATA5_CONN_EMMC0_DATA5	0x00000021
+				SC_P_EMMC0_DATA6_CONN_EMMC0_DATA6	0x00000021
+				SC_P_EMMC0_DATA7_CONN_EMMC0_DATA7	0x00000021
+				SC_P_EMMC0_STROBE_CONN_EMMC0_STROBE	0x00000041
+				SC_P_EMMC0_RESET_B_CONN_EMMC0_RESET_B	0x00000021
+			>;
+		};
+
+		pinctrl_usdhc2_gpio: usdhc2grpgpio {
+			fsl,pins = <
+				SC_P_USDHC1_DATA6_LSIO_GPIO5_IO21	0x00000021
+				SC_P_USDHC1_DATA7_LSIO_GPIO5_IO22	0x00000021
+			>;
+		};
+
+		pinctrl_usdhc2: usdhc2grp {
+			fsl,pins = <
+				SC_P_USDHC1_CLK_CONN_USDHC1_CLK			0x06000041
+				SC_P_USDHC1_CMD_CONN_USDHC1_CMD			0x00000021
+				SC_P_USDHC1_DATA0_CONN_USDHC1_DATA0		0x00000021
+				SC_P_USDHC1_DATA1_CONN_USDHC1_DATA1		0x00000021
+				SC_P_USDHC1_DATA2_CONN_USDHC1_DATA2		0x00000021
+				SC_P_USDHC1_DATA3_CONN_USDHC1_DATA3		0x00000021
+				SC_P_USDHC1_VSELECT_CONN_USDHC1_VSELECT		0x00000021
+			>;
+		};
+	};
+};
+
+&gpio1 {
+	status = "okay";
+};
+
+&gpio2 {
+	status = "okay";
+};
+
+&gpio4 {
+	status = "okay";
+};
+
+&gpio5 {
+	status = "okay";
+};
+
+&usbotg1 {
+	srp-disable;
+	hnp-disable;
+	adp-disable;
+	disable-over-current;
+	dr_mode = "host";
+	status = "okay";
+};
+
+&usbh1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usbh1>;
+	srp-disable;
+	hnp-disable;
+	adp-disable;
+	disable-over-current;
+	status = "okay";
+};
+
+&usbotg3 {
+	dr_mode = "otg";
+	status = "okay";
+};
+
+&usdhc1 {
+	pinctrl-names = "default", "state_100mhz", "state_200mhz";
+	pinctrl-0 = <&pinctrl_usdhc1>;
+	pinctrl-1 = <&pinctrl_usdhc1>;
+	pinctrl-2 = <&pinctrl_usdhc1>;
+	bus-width = <8>;
+	non-removable;
+	status = "okay";
+};
+
+&usdhc2 {
+	pinctrl-names = "default", "state_100mhz", "state_200mhz";
+	pinctrl-0 = <&pinctrl_usdhc2>, <&pinctrl_usdhc2_gpio>;
+	pinctrl-1 = <&pinctrl_usdhc2>, <&pinctrl_usdhc2_gpio>;
+	pinctrl-2 = <&pinctrl_usdhc2>, <&pinctrl_usdhc2_gpio>;
+	bus-width = <4>;
+	cd-gpios = <&gpio5 22 GPIO_ACTIVE_LOW>;
+	wp-gpios = <&gpio5 21 GPIO_ACTIVE_HIGH>;
+	status = "okay";
+};
+
+&fec1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_fec1>;
+	phy-mode = "rgmii-txid";
+	phy-handle = <&ethphy0>;
+	fsl,magic-packet;
+	fsl,rgmii_rxc_dly;
+	fsl,ar8031-phy-fixup; /* ??? */
+	phy-reset-duration = <10>;
+	phy-reset-gpios = <&gpio3 27 GPIO_ACTIVE_LOW>;
+
+	status = "okay";
+
+	mdio {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		ethphy0: ethernet-phy@0 {
+			compatible = "ethernet-phy-ieee802.3-c22";
+			reg = <0>;
+			at803x,eee-disabled;
+			at803x,vddio-1p8v;
+		};
+
+		ethphy1: ethernet-phy@1 {
+			compatible = "ethernet-phy-ieee802.3-c22";
+			reg = <1>;
+			at803x,eee-disabled;
+			at803x,vddio-1p8v;
+		};
+	};
+};
+
+&fec2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_fec2>;
+	phy-mode = "rgmii";
+	phy-handle = <&ethphy1>;
+	fsl,ar8031-phy-fixup;
+	fsl,magic-packet;
+	phy-reset-duration = <10>;
+	phy-reset-gpios = <&gpio3 28 1>;
+	status = "okay";
+};
+
+&flexspi0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexspi0>;
+	status = "okay";
+
+	flash0: mt35xu2gcba@0 {
+		reg = <0>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "spi-flash", "jedec,spi-nor";
+		spi-max-frequency = <29000000>;
+		spi-nor,ddr-quad-read-dummy = <8>;
+	};
+};
+
+&lpuart0 { /* console */
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_lpuart0>;
+	status = "okay";
+};
+
+
+&thermal_zones {
+	pmic-thermal0 {
+		polling-delay-passive = <250>;
+		polling-delay = <2000>;
+		thermal-sensors = <&tsens 5>;
+		trips {
+			pmic_alert0: trip0 {
+				temperature = <110000>;
+				hysteresis = <2000>;
+				type = "passive";
+			};
+			pmic_crit0: trip1 {
+				temperature = <125000>;
+				hysteresis = <2000>;
+				type = "critical";
+			};
+		};
+		cooling-maps {
+			map0 {
+				trip = <&pmic_alert0>;
+				cooling-device =
+				<&A53_0 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>;
+			};
+			map1 {
+				trip = <&pmic_alert0>;
+				cooling-device =
+				<&A72_0 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>;
+			};
+		};
+	};
+};
+
diff --git a/arch/arm/mach-imx/imx8/Kconfig b/arch/arm/mach-imx/imx8/Kconfig
index f6ead7218d..40603b5c40 100644
--- a/arch/arm/mach-imx/imx8/Kconfig
+++ b/arch/arm/mach-imx/imx8/Kconfig
@@ -112,6 +112,11 @@ config TARGET_GIEDI
 	select BOARD_LATE_INIT
 	select IMX8QXP
 
+config TARGET_CL_SOM_IMX8MAX
+	bool "Support CL-SOM-iMX8MAX board"
+	select BOARD_LATE_INIT
+	select IMX8QM
+
 config TARGET_IMX8QM_MEK
 	bool "Support i.MX8QM MEK board"
 	select BOARD_LATE_INIT
@@ -186,6 +191,7 @@ source "board/advantech/imx8qm_rom7720_a1/Kconfig"
 source "board/toradex/apalis-imx8/Kconfig"
 source "board/toradex/colibri-imx8x/Kconfig"
 source "board/siemens/capricorn/Kconfig"
+source "board/compulab/cl-som-imx8max/Kconfig"
 
 config SNVS_SEC_SC
 	bool "Support SNVS configuration"
diff --git a/board/compulab/cl-som-imx8max/Kconfig b/board/compulab/cl-som-imx8max/Kconfig
new file mode 100644
index 0000000000..428c48b426
--- /dev/null
+++ b/board/compulab/cl-som-imx8max/Kconfig
@@ -0,0 +1,14 @@
+if TARGET_CL_SOM_IMX8MAX
+
+config SYS_BOARD
+	default "cl-som-imx8max"
+
+config SYS_VENDOR
+	default "compulab"
+
+config SYS_CONFIG_NAME
+	default "cl-som-imx8max"
+
+source "board/freescale/common/Kconfig"
+
+endif
diff --git a/board/compulab/cl-som-imx8max/MAINTAINERS b/board/compulab/cl-som-imx8max/MAINTAINERS
new file mode 100644
index 0000000000..b448d00452
--- /dev/null
+++ b/board/compulab/cl-som-imx8max/MAINTAINERS
@@ -0,0 +1,6 @@
+i.MX8QM CL-SOM-iMX8MAX BOARD
+M:	Ilya Ledvich <ilya@compulab.co.il>
+S:	Maintained
+F:	board/compulab/cl-som-imx8max/
+F:	include/configs/cl-som-imx8max.h
+F:	configs/cl_som_imx8max_defconfig
diff --git a/board/compulab/cl-som-imx8max/Makefile b/board/compulab/cl-som-imx8max/Makefile
new file mode 100644
index 0000000000..b29dc7d01a
--- /dev/null
+++ b/board/compulab/cl-som-imx8max/Makefile
@@ -0,0 +1,8 @@
+#
+# Copyright 2018 NXP
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y += cl-som-imx8max.o
+obj-$(CONFIG_SPL_BUILD) += spl.o
diff --git a/board/compulab/cl-som-imx8max/README b/board/compulab/cl-som-imx8max/README
new file mode 100644
index 0000000000..a187ad8a09
--- /dev/null
+++ b/board/compulab/cl-som-imx8max/README
@@ -0,0 +1,54 @@
+U-Boot for the NXP i.MX8QM EVK board
+
+Quick Start
+===========
+
+- Build the ARM Trusted firmware binary
+- Get scfw_tcm.bin and ahab-container.img
+- Build U-Boot
+- Flash the binary into the SD card
+- Boot
+
+Get and Build the ARM Trusted firmware
+======================================
+
+$ git clone https://source.codeaurora.org/external/imx/imx-atf
+$ cd imx-atf/
+$ git checkout origin/imx_4.14.78_1.0.0_ga -b imx_4.14.78_1.0.0_ga
+$ make PLAT=imx8qm bl31
+
+Get scfw_tcm.bin and ahab-container.img
+==============================
+
+$ wget https://www.nxp.com/lgfiles/NMG/MAD/YOCTO/imx-sc-firmware-1.1.bin
+$ chmod +x imx-sc-firmware-1.1.bin
+$ ./imx-sc-firmware-1.1.bin
+$ wget https://www.nxp.com/lgfiles/NMG/MAD/YOCTO/firmware-imx-8.0.bin
+$ chmod +x firmware-imx-8.0.bin
+$ ./firmware-imx-8.0.bin
+
+Copy the following binaries to U-Boot folder:
+
+$ cp imx-atf/build/imx8qm/release/bl31.bin .
+$ cp u-boot/u-boot.bin .
+
+Copy the following firmwares U-Boot folder :
+
+$ cp firmware-imx-7.6/firmware/seco/ahab-container.img .
+$ cp imx-sc-firmware-0.7/mx8qm-mek-scfw-tcm.bin	.
+
+Build U-Boot
+============
+$ make imx8qm_mek_defconfig
+$ make flash.bin
+
+Flash the binary into the SD card
+=================================
+
+Burn the flash.bin binary to SD card offset 32KB:
+
+$ sudo dd if=flash.bin of=/dev/sd[x] bs=1024 seek=32
+
+Boot
+====
+Set Boot switch SW2: 1100.
diff --git a/board/compulab/cl-som-imx8max/cl-som-imx8max.c b/board/compulab/cl-som-imx8max/cl-som-imx8max.c
new file mode 100644
index 0000000000..bfe31813b6
--- /dev/null
+++ b/board/compulab/cl-som-imx8max/cl-som-imx8max.c
@@ -0,0 +1,480 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2018 NXP
+ */
+
+#include <common.h>
+#include <cpu_func.h>
+#include <env.h>
+#include <errno.h>
+#include <init.h>
+#include <linux/libfdt.h>
+#include <fdt_support.h>
+#include <asm/io.h>
+#include <asm/gpio.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/sci/sci.h>
+#include <asm/arch/imx8-pins.h>
+#include <asm/arch/snvs_security_sc.h>
+#include <mmc.h>
+#include <usb.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/mach-imx/boot_mode.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define ENET_INPUT_PAD_CTRL	((SC_PAD_CONFIG_OD_IN << PADRING_CONFIG_SHIFT) | (SC_PAD_ISO_OFF << PADRING_LPCONFIG_SHIFT) \
+						| (SC_PAD_28FDSOI_DSE_18V_10MA << PADRING_DSE_SHIFT) | (SC_PAD_28FDSOI_PS_PU << PADRING_PULL_SHIFT))
+
+#define ENET_NORMAL_PAD_CTRL	((SC_PAD_CONFIG_NORMAL << PADRING_CONFIG_SHIFT) | (SC_PAD_ISO_OFF << PADRING_LPCONFIG_SHIFT) \
+						| (SC_PAD_28FDSOI_DSE_18V_10MA << PADRING_DSE_SHIFT) | (SC_PAD_28FDSOI_PS_PU << PADRING_PULL_SHIFT))
+
+
+#define GPIO_PAD_CTRL	((SC_PAD_CONFIG_NORMAL << PADRING_CONFIG_SHIFT) | (SC_PAD_ISO_OFF << PADRING_LPCONFIG_SHIFT) \
+						| (SC_PAD_28FDSOI_DSE_DV_HIGH << PADRING_DSE_SHIFT) | (SC_PAD_28FDSOI_PS_PU << PADRING_PULL_SHIFT))
+
+
+#define UART_PAD_CTRL	((SC_PAD_CONFIG_OUT_IN << PADRING_CONFIG_SHIFT) | (SC_PAD_ISO_OFF << PADRING_LPCONFIG_SHIFT) \
+						| (SC_PAD_28FDSOI_DSE_DV_HIGH << PADRING_DSE_SHIFT) | (SC_PAD_28FDSOI_PS_PU << PADRING_PULL_SHIFT))
+
+static iomux_cfg_t uart0_pads[] = {
+	SC_P_UART0_RX | MUX_PAD_CTRL(UART_PAD_CTRL),
+	SC_P_UART0_TX | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+
+static void setup_iomux_uart(void)
+{
+	imx8_iomux_setup_multiple_pads(uart0_pads, ARRAY_SIZE(uart0_pads));
+}
+
+int board_early_init_f(void)
+{
+	sc_pm_clock_rate_t rate = SC_80MHZ;
+	int ret;
+
+	/* When start u-boot in XEN VM, directly return */
+	if (IS_ENABLED(CONFIG_XEN)) {
+		writel(0xF53535F5, (void __iomem *)0x80000000);
+		return 0;
+	}
+
+	/* Set UART0 clock root to 80 MHz */
+	ret = sc_pm_setup_uart(SC_R_UART_0, rate);
+	if (ret)
+		return ret;
+
+	setup_iomux_uart();
+
+/* Dual bootloader feature will require CAAM access, but JR0 and JR1 will be
+ * assigned to seco for imx8, use JR3 instead.
+ */
+#if defined(CONFIG_SPL_BUILD) && defined(CONFIG_DUAL_BOOTLOADER)
+	sc_pm_set_resource_power_mode(-1, SC_R_CAAM_JR3, SC_PM_PW_MODE_ON);
+	sc_pm_set_resource_power_mode(-1, SC_R_CAAM_JR3_OUT, SC_PM_PW_MODE_ON);
+#endif
+
+	return 0;
+}
+
+
+#if IS_ENABLED(CONFIG_FEC_MXC)
+#include <miiphy.h>
+
+#ifndef CONFIG_DM_ETH
+static iomux_cfg_t pad_enet1[] = {
+	SC_P_ENET1_RGMII_RX_CTL | MUX_PAD_CTRL(ENET_INPUT_PAD_CTRL),
+	SC_P_ENET1_RGMII_RXD0 | MUX_PAD_CTRL(ENET_INPUT_PAD_CTRL),
+	SC_P_ENET1_RGMII_RXD1 | MUX_PAD_CTRL(ENET_INPUT_PAD_CTRL),
+	SC_P_ENET1_RGMII_RXD2 | MUX_PAD_CTRL(ENET_INPUT_PAD_CTRL),
+	SC_P_ENET1_RGMII_RXD3 | MUX_PAD_CTRL(ENET_INPUT_PAD_CTRL),
+	SC_P_ENET1_RGMII_RXC | MUX_PAD_CTRL(ENET_INPUT_PAD_CTRL),
+	SC_P_ENET1_RGMII_TX_CTL | MUX_PAD_CTRL(ENET_NORMAL_PAD_CTRL),
+	SC_P_ENET1_RGMII_TXD0 | MUX_PAD_CTRL(ENET_NORMAL_PAD_CTRL),
+	SC_P_ENET1_RGMII_TXD1 | MUX_PAD_CTRL(ENET_NORMAL_PAD_CTRL),
+	SC_P_ENET1_RGMII_TXD2 | MUX_PAD_CTRL(ENET_NORMAL_PAD_CTRL),
+	SC_P_ENET1_RGMII_TXD3 | MUX_PAD_CTRL(ENET_NORMAL_PAD_CTRL),
+	SC_P_ENET1_RGMII_TXC | MUX_PAD_CTRL(ENET_NORMAL_PAD_CTRL),
+
+	/* Shared MDIO */
+	SC_P_ENET0_MDC | MUX_PAD_CTRL(ENET_NORMAL_PAD_CTRL),
+	SC_P_ENET0_MDIO | MUX_PAD_CTRL(ENET_NORMAL_PAD_CTRL),
+};
+
+static iomux_cfg_t pad_enet0[] = {
+	SC_P_ENET0_RGMII_RX_CTL | MUX_PAD_CTRL(ENET_INPUT_PAD_CTRL),
+	SC_P_ENET0_RGMII_RXD0 | MUX_PAD_CTRL(ENET_INPUT_PAD_CTRL),
+	SC_P_ENET0_RGMII_RXD1 | MUX_PAD_CTRL(ENET_INPUT_PAD_CTRL),
+	SC_P_ENET0_RGMII_RXD2 | MUX_PAD_CTRL(ENET_INPUT_PAD_CTRL),
+	SC_P_ENET0_RGMII_RXD3 | MUX_PAD_CTRL(ENET_INPUT_PAD_CTRL),
+	SC_P_ENET0_RGMII_RXC | MUX_PAD_CTRL(ENET_INPUT_PAD_CTRL),
+	SC_P_ENET0_RGMII_TX_CTL | MUX_PAD_CTRL(ENET_NORMAL_PAD_CTRL),
+	SC_P_ENET0_RGMII_TXD0 | MUX_PAD_CTRL(ENET_NORMAL_PAD_CTRL),
+	SC_P_ENET0_RGMII_TXD1 | MUX_PAD_CTRL(ENET_NORMAL_PAD_CTRL),
+	SC_P_ENET0_RGMII_TXD2 | MUX_PAD_CTRL(ENET_NORMAL_PAD_CTRL),
+	SC_P_ENET0_RGMII_TXD3 | MUX_PAD_CTRL(ENET_NORMAL_PAD_CTRL),
+	SC_P_ENET0_RGMII_TXC | MUX_PAD_CTRL(ENET_NORMAL_PAD_CTRL),
+
+	/* Shared MDIO */
+	SC_P_ENET0_MDC | MUX_PAD_CTRL(ENET_NORMAL_PAD_CTRL),
+	SC_P_ENET0_MDIO | MUX_PAD_CTRL(ENET_NORMAL_PAD_CTRL),
+};
+
+static void setup_iomux_fec(void)
+{
+	if (0 == CONFIG_FEC_ENET_DEV)
+		imx8_iomux_setup_multiple_pads(pad_enet0, ARRAY_SIZE(pad_enet0));
+	else
+		imx8_iomux_setup_multiple_pads(pad_enet1, ARRAY_SIZE(pad_enet1));
+}
+
+int board_eth_init(bd_t *bis)
+{
+	int ret;
+	struct power_domain pd;
+
+	printf("[%s] %d\n", __func__, __LINE__);
+
+	if (CONFIG_FEC_ENET_DEV) {
+		if (!power_domain_lookup_name("conn_enet1", &pd))
+			power_domain_on(&pd);
+	} else {
+		if (!power_domain_lookup_name("conn_enet0", &pd))
+			power_domain_on(&pd);
+	}
+
+	setup_iomux_fec();
+
+	ret = fecmxc_initialize_multi(bis, CONFIG_FEC_ENET_DEV,
+		CONFIG_FEC_MXC_PHYADDR, IMX_FEC_BASE);
+	if (ret)
+		printf("FEC1 MXC: %s:failed\n", __func__);
+
+	return ret;
+}
+#endif
+
+int board_phy_config(struct phy_device *phydev)
+{
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x1f);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, 0x8);
+
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x00);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, 0x82ee);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x05);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, 0x100);
+
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+#endif
+
+static int ram_detect = 0;
+
+static void board_dram_update(void)
+{
+	printf("RAM Detect size: %dGB \n", 2 << ram_detect);
+}
+
+static void board_gpio_init(void)
+{
+	int ret;
+	struct gpio_desc desc;
+	int val;
+
+	ret = dm_gpio_lookup_name("GPIO4_29", &desc);
+	if (ret) {
+		printf("%s lookup GPIO@4_29 failed ret = %d\n", __func__, ret);
+		return;
+	}
+
+	ret = dm_gpio_request(&desc, "pcie_nrst");
+	if (ret) {
+		printf("%s request pcie_nrst failed ret = %d\n", __func__, ret);
+		return;
+	}
+
+	dm_gpio_set_dir_flags(&desc, GPIOD_IS_OUT | GPIOD_IS_OUT_ACTIVE);
+
+
+	ret = dm_gpio_lookup_name("GPIO2_13", &desc);
+	if (ret) {
+		printf("%s lookup GPIO@2_13 failed ret = %d\n", __func__, ret);
+		return;
+	}
+
+	ret = dm_gpio_request(&desc, "otg1_mux_sel");
+	if (ret) {
+		printf("%s request otg1_mux_sel failed ret = %d\n", __func__, ret);
+		return;
+	}
+
+	dm_gpio_set_dir_flags(&desc, GPIOD_IS_OUT | GPIOD_IS_OUT_ACTIVE);
+
+	ret = dm_gpio_lookup_name("GPIO0_0", &desc);
+	if (ret) {
+		printf("%s lookup GPIO@0_0 failed ret = %d\n", __func__, ret);
+		return;
+	}
+
+	ret = dm_gpio_request(&desc, "ram_detect_0");
+	if (ret) {
+		printf("%s request ram_detect_0 failed ret = %d\n", __func__, ret);
+		return;
+	}
+
+	dm_gpio_set_dir_flags(&desc, GPIOD_IS_IN);
+
+	ram_detect = dm_gpio_get_value(&desc);
+
+	ret = dm_gpio_lookup_name("GPIO0_2", &desc);
+	if (ret) {
+		printf("%s lookup GPIO@0_2 failed ret = %d\n", __func__, ret);
+		return;
+	}
+
+	ret = dm_gpio_request(&desc, "ram_detect_1");
+	if (ret) {
+		printf("%s request ram_detect_1 failed ret = %d\n", __func__, ret);
+		return;
+	}
+
+	dm_gpio_set_dir_flags(&desc, GPIOD_IS_IN);
+	ram_detect |= (dm_gpio_get_value(&desc) & 0x1) << 1;
+
+	ret = dm_gpio_lookup_name("GPIO0_1", &desc);
+	if (ret) {
+		printf("%s lookup GPIO@0_1 failed ret = %d\n", __func__, ret);
+		return;
+	}
+
+	ret = dm_gpio_request(&desc, "ram_detect_2");
+	if (ret) {
+		printf("%s request ram_detect_2 failed ret = %d\n", __func__, ret);
+		return;
+	}
+
+	dm_gpio_set_dir_flags(&desc, GPIOD_IS_IN);
+	ram_detect |= (dm_gpio_get_value(&desc) & 0x1) << 2;
+}
+
+int checkboard(void)
+{
+	puts("Board: CL-SOM-iMX8MAX\n");
+
+	build_info();
+	print_bootinfo();
+
+	return 0;
+}
+
+#ifdef CONFIG_USB
+
+int board_usb_init(int index, enum usb_init_type init)
+{
+	int ret = 0;
+
+	if (index == 1) {
+		if (init == USB_INIT_HOST) {
+#ifdef CONFIG_USB_CDNS3_GADGET
+		} else {
+#endif
+		}
+	}
+
+	return ret;
+
+}
+
+int board_usb_cleanup(int index, enum usb_init_type init)
+{
+	int ret = 0;
+
+	if (index == 1) {
+		if (init == USB_INIT_HOST) {
+		}
+	}
+
+	return ret;
+}
+#endif
+
+int board_init(void)
+{
+	if (IS_ENABLED(CONFIG_XEN))
+		return 0;
+
+	board_gpio_init();
+	board_dram_update();
+
+#ifdef CONFIG_SNVS_SEC_SC_AUTO
+	{
+		int ret = snvs_security_sc_init();
+
+		if (ret)
+			return ret;
+	}
+#endif
+
+	return 0;
+}
+
+void board_quiesce_devices(void)
+{
+	const char *power_on_devices[] = {
+		"dma_lpuart0",
+	};
+
+	if (IS_ENABLED(CONFIG_XEN)) {
+		/* Clear magic number to let xen know uboot is over */
+		writel(0x0, (void __iomem *)0x80000000);
+		return;
+	}
+
+	power_off_pd_devices(power_on_devices, ARRAY_SIZE(power_on_devices));
+}
+
+/*
+ * Board specific reset that is system reset.
+ */
+void reset_cpu(ulong addr)
+{
+	sc_pm_reboot(-1, SC_PM_RESET_TYPE_COLD);
+	while(1);
+}
+
+#ifdef CONFIG_OF_BOARD_SETUP
+int ft_board_setup(void *blob, bd_t *bd)
+{
+	return 0;
+}
+#endif
+
+int board_mmc_get_env_dev(int devno)
+{
+	return CONFIG_SYS_MMC_ENV_DEV;
+}
+
+int mmc_map_to_kernel_blk(int dev_no)
+{
+	return dev_no;
+}
+
+static int check_mmc_autodetect(void)
+{
+	char *autodetect_str = env_get("mmcautodetect");
+
+	if ((autodetect_str != NULL) &&
+		(strcmp(autodetect_str, "yes") == 0)) {
+		return 1;
+	}
+
+	return 0;
+}
+
+void board_late_mmc_env_init(void)
+{
+	char cmd[32];
+	char mmcblk[32];
+	u32 dev_no = mmc_get_env_dev();
+
+	if (!check_mmc_autodetect())
+		return;
+
+	env_set_ulong("mmcdev", dev_no);
+
+	/* Set mmcblk env */
+	sprintf(mmcblk, "/dev/mmcblk%dp2 rootwait rw",
+		mmc_map_to_kernel_blk(dev_no));
+	env_set("mmcroot", mmcblk);
+
+	sprintf(cmd, "mmc dev %d", dev_no);
+	run_command(cmd, 0);
+}
+
+/*
+ * Detect a boot device and write an appropriate value into
+ * "bootdev" env
+ */
+void board_set_bootdev(void)
+{
+	enum boot_device bt_dev = get_boot_device();
+
+	switch (bt_dev) {
+	case SD2_BOOT:
+		env_set("bootdev", "sd");
+		break;
+	case MMC1_BOOT:
+		env_set("bootdev", "emmc");
+		break;
+	case USB_BOOT:
+		env_set("bootdev", "usb");
+		break;
+	default:
+		env_set("bootdev", "default");
+		break;
+	}
+
+	return;
+}
+
+extern uint32_t _end_ofs;
+int board_late_init(void)
+{
+	char *fdt_file;
+	bool m4_boot;
+
+	board_set_bootdev();
+
+	build_info();
+
+#ifdef CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG
+	env_set("board_name", "CL-SOM-iMX8MAX");
+	env_set("board_rev", "iMX8QM");
+#endif
+
+	env_set("sec_boot", "no");
+#ifdef CONFIG_AHAB_BOOT
+	env_set("sec_boot", "yes");
+#endif
+
+	fdt_file = env_get("fdt_file");
+	m4_boot = check_m4_parts_boot();
+
+	if (fdt_file && !strcmp(fdt_file, "undefined")) {
+		if (m4_boot)
+			env_set("fdt_file", "cl-som-imx8max-rpmsg.dtb");
+		else
+			env_set("fdt_file", "cl-som-imx8max.dtb");
+	}
+
+#ifdef CONFIG_ENV_IS_IN_MMC
+	board_late_mmc_env_init();
+#endif
+
+#if defined(CONFIG_IMX_LOAD_HDMI_FIMRWARE_RX) || defined(CONFIG_IMX_LOAD_HDMI_FIMRWARE_TX)
+	char *end_of_uboot;
+	char command[256];
+	end_of_uboot = (char *)(ulong)(CONFIG_SYS_TEXT_BASE + _end_ofs + fdt_totalsize(gd->fdt_blob));
+	end_of_uboot += 9;
+
+	/* load hdmitxfw.bin and hdmirxfw.bin*/
+	memcpy((void *)IMX_HDMI_FIRMWARE_LOAD_ADDR, end_of_uboot,
+			IMX_HDMITX_FIRMWARE_SIZE + IMX_HDMIRX_FIRMWARE_SIZE);
+
+#ifdef CONFIG_IMX_LOAD_HDMI_FIMRWARE_TX
+	sprintf(command, "hdp load 0x%x", IMX_HDMI_FIRMWARE_LOAD_ADDR);
+	run_command(command, 0);
+#endif
+#ifdef CONFIG_IMX_LOAD_HDMI_FIMRWARE_RX
+	sprintf(command, "hdprx load 0x%x",
+			IMX_HDMI_FIRMWARE_LOAD_ADDR + IMX_HDMITX_FIRMWARE_SIZE);
+	run_command(command, 0);
+#endif
+#endif /* CONFIG_IMX_LOAD_HDMI_FIMRWARE_RX || CONFIG_IMX_LOAD_HDMI_FIMRWARE_TX */
+
+	return 0;
+}
+
diff --git a/board/compulab/cl-som-imx8max/imximage.cfg b/board/compulab/cl-som-imx8max/imximage.cfg
new file mode 100644
index 0000000000..7dc6b93eb5
--- /dev/null
+++ b/board/compulab/cl-som-imx8max/imximage.cfg
@@ -0,0 +1,19 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright 2018 NXP
+ */
+
+#define __ASSEMBLY__
+
+/* Boot from SD, sector size 0x400 */
+BOOT_FROM SD 0x400
+/* SoC type IMX8QM */
+SOC_TYPE IMX8QM
+/* Append seco container image */
+APPEND mx8qm-ahab-container.img
+/* Create the 2nd container */
+CONTAINER
+/* Add scfw image with exec attribute */
+IMAGE SCU mx8qm-mek-scfw-tcm.bin
+/* Add ATF image with exec attribute */
+IMAGE A35 spl/u-boot-spl.bin 0x00100000
diff --git a/board/compulab/cl-som-imx8max/spl.c b/board/compulab/cl-som-imx8max/spl.c
new file mode 100644
index 0000000000..715772b0d1
--- /dev/null
+++ b/board/compulab/cl-som-imx8max/spl.c
@@ -0,0 +1,65 @@
+/*
+ * Copyright 2018 NXP
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <spl.h>
+#include <dm/uclass.h>
+#include <dm/device.h>
+#include <dm/uclass-internal.h>
+#include <dm/device-internal.h>
+#include <dm/lists.h>
+#include <bootm.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+void spl_board_init(void)
+{
+	struct udevice *dev;
+
+	uclass_find_first_device(UCLASS_MISC, &dev);
+
+	for (; dev; uclass_find_next_device(&dev)) {
+		if (device_probe(dev))
+			continue;
+	}
+
+	board_early_init_f();
+
+	timer_init();
+
+#ifdef CONFIG_SPL_SERIAL_SUPPORT
+	preloader_console_init();
+
+	puts("Normal Boot\n");
+#endif
+
+}
+
+void spl_board_prepare_for_boot(void)
+{
+	board_quiesce_devices();
+}
+
+#ifdef CONFIG_SPL_LOAD_FIT
+int board_fit_config_name_match(const char *name)
+{
+	/* Just empty function now - can't decide what to choose */
+	debug("%s: %s\n", __func__, name);
+
+	return 0;
+}
+#endif
+
+void board_init_f(ulong dummy)
+{
+	/* Clear the BSS. */
+	memset(__bss_start, 0, __bss_end - __bss_start);
+
+	arch_cpu_init();
+
+	board_init_r(NULL, 0);
+}
diff --git a/board/compulab/cl-som-imx8max/spl.c.bak b/board/compulab/cl-som-imx8max/spl.c.bak
new file mode 100644
index 0000000000..db11e89156
--- /dev/null
+++ b/board/compulab/cl-som-imx8max/spl.c.bak
@@ -0,0 +1,65 @@
+/*
+ * Copyright 2018 NXP
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <spl.h>
+#include <dm/uclass.h>
+#include <dm/device.h>
+#include <dm/uclass-internal.h>
+#include <dm/device-internal.h>
+#include <dm/lists.h>
+#include <bootm.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+void spl_board_init(void)
+{
+	struct udevice *dev;
+
+	uclass_find_first_device(UCLASS_MISC, &dev);
+
+	for (; dev; uclass_find_next_device(&dev)) {
+		if (device_probe(dev))
+			continue;
+	}
+
+	board_early_init_f();
+
+	timer_init();
+
+	preloader_console_init();
+
+	while (1) {
+		puts("Normal Boot\n");
+	}
+
+}
+
+void spl_board_prepare_for_boot(void)
+{
+	board_quiesce_devices();
+}
+
+#ifdef CONFIG_SPL_LOAD_FIT
+int board_fit_config_name_match(const char *name)
+{
+	/* Just empty function now - can't decide what to choose */
+	debug("%s: %s\n", __func__, name);
+
+	return 0;
+}
+#endif
+
+void board_init_f(ulong dummy)
+{
+	/* Clear the BSS. */
+	memset(__bss_start, 0, __bss_end - __bss_start);
+
+	arch_cpu_init();
+
+	board_init_r(NULL, 0);
+}
diff --git a/board/compulab/cl-som-imx8max/uboot-container.cfg b/board/compulab/cl-som-imx8max/uboot-container.cfg
new file mode 100644
index 0000000000..6cc47cd102
--- /dev/null
+++ b/board/compulab/cl-som-imx8max/uboot-container.cfg
@@ -0,0 +1,13 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright 2019 NXP
+ */
+
+#define __ASSEMBLY__
+
+/* This file is to create a container image could be loaded by SPL */
+BOOT_FROM SD 0x400
+SOC_TYPE IMX8QM
+CONTAINER
+IMAGE A35 bl31.bin	0x80000000
+IMAGE A35 u-boot.bin	CONFIG_SYS_TEXT_BASE
diff --git a/configs/cl_som_imx8max_defconfig b/configs/cl_som_imx8max_defconfig
new file mode 100644
index 0000000000..9d50228f21
--- /dev/null
+++ b/configs/cl_som_imx8max_defconfig
@@ -0,0 +1,195 @@
+CONFIG_ARM=y
+CONFIG_SPL_SYS_ICACHE_OFF=y
+CONFIG_SPL_SYS_DCACHE_OFF=y
+CONFIG_ARCH_IMX8=y
+CONFIG_SYS_TEXT_BASE=0x80020000
+CONFIG_SPL_GPIO_SUPPORT=y
+CONFIG_SPL_LIBCOMMON_SUPPORT=y
+CONFIG_SPL_LIBGENERIC_SUPPORT=y
+CONFIG_SYS_MALLOC_F_LEN=0x8000
+CONFIG_ENV_SIZE=0x2000
+CONFIG_ENV_OFFSET=0x300000
+CONFIG_DM_GPIO=y
+CONFIG_SPL_LOAD_IMX_CONTAINER=y
+CONFIG_IMX_CONTAINER_CFG="board/compulab/cl-som-imx8max/uboot-container.cfg"
+CONFIG_TARGET_CL_SOM_IMX8MAX=y
+CONFIG_SPL_MMC_SUPPORT=y
+CONFIG_SPL_EFI_PARTITION=n
+CONFIG_SPL_DOS_PARTITION=n
+CONFIG_SPL_DM_SEQ_ALIAS=y
+CONFIG_SPL_SERIAL_SUPPORT=y
+CONFIG_SPL_DRIVERS_MISC_SUPPORT=y
+CONFIG_USE_TINY_PRINTF=y
+CONFIG_NR_DRAM_BANKS=4
+CONFIG_SPL=y
+CONFIG_PANIC_HANG=y
+CONFIG_SPL_TEXT_BASE=0x100000
+CONFIG_OF_SYSTEM_SETUP=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/compulab/cl-som-imx8max/imximage.cfg"
+CONFIG_BOOTDELAY=3
+CONFIG_LOG=y
+CONFIG_SPL_BOARD_INIT=y
+# CONFIG_SPL_SYS_MALLOC_SIMPLE is not set
+CONFIG_SPL_SEPARATE_BSS=y
+CONFIG_SPL_POWER_SUPPORT=y
+CONFIG_SPL_POWER_DOMAIN=y
+CONFIG_SPL_WATCHDOG_SUPPORT=y
+CONFIG_HUSH_PARSER=y
+CONFIG_SYS_PROMPT="CL-SOM-iMX8MAX # "
+CONFIG_CMD_CPU=y
+# CONFIG_BOOTM_NETBSD is not set
+# CONFIG_CMD_IMPORTENV is not set
+CONFIG_CMD_MEMINFO=y
+CONFIG_CMD_MEMTEST=y
+CONFIG_CMD_CLK=y
+CONFIG_CMD_DM=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_DHCP=y
+CONFIG_BOOTP_PREFER_SERVERIP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_SPL_OF_CONTROL=y
+CONFIG_DEFAULT_DEVICE_TREE="cl-som-imx8max"
+CONFIG_DEFAULT_FDT_FILE="imx8qm-sbc-imx8max.dtb"
+CONFIG_ENV_IS_IN_MMC=y
+CONFIG_SYS_RELOC_GD_ENV_ADDR=y
+CONFIG_NET_RANDOM_ETHADDR=y
+CONFIG_SPL_DM=y
+CONFIG_SPL_CLK=y
+CONFIG_CLK_IMX8=y
+CONFIG_CPU=y
+CONFIG_MXC_GPIO=y
+CONFIG_DM_PCA953X=y
+CONFIG_DM_I2C=y
+CONFIG_SYS_I2C_IMX_LPI2C=y
+CONFIG_I2C_MUX=y
+CONFIG_I2C_MUX_PCA954x=y
+CONFIG_MISC=y
+CONFIG_DM_MMC=y
+CONFIG_SUPPORT_EMMC_BOOT=y
+CONFIG_FSL_USDHC=y
+CONFIG_MMC_IO_VOLTAGE=y
+CONFIG_MMC_UHS_SUPPORT=y
+CONFIG_MMC_HS400_SUPPORT=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PHYLIB=y
+CONFIG_PHY_ADDR_ENABLE=y
+CONFIG_PHY_ATHEROS=y
+CONFIG_DM_ETH=y
+CONFIG_PHY_GIGE=y
+CONFIG_FEC_MXC_SHARE_MDIO=y
+CONFIG_FEC_MXC_MDIO_BASE=0x5B040000
+CONFIG_FEC_MXC=y
+CONFIG_MII=y
+CONFIG_PINCTRL=y
+CONFIG_SPL_PINCTRL=y
+CONFIG_PINCTRL_IMX8=y
+CONFIG_POWER_DOMAIN=y
+CONFIG_IMX8_POWER_DOMAIN=y
+CONFIG_DM_REGULATOR=y
+CONFIG_SPL_DM_REGULATOR=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_REGULATOR_GPIO=y
+CONFIG_SPL_DM_REGULATOR_FIXED=y
+CONFIG_DM_SERIAL=y
+CONFIG_FSL_LPUART=y
+CONFIG_SPL_TINY_MEMSET=y
+# CONFIG_EFI_LOADER is not set
+
+CONFIG_CMD_FUSE=y
+CONFIG_CMD_MEMTEST=y
+
+CONFIG_IMX_BOOTAUX=y
+
+CONFIG_DM_THERMAL=y
+CONFIG_IMX_SCU_THERMAL=y
+CONFIG_SPI=y
+CONFIG_FSL_FSPI=y
+CONFIG_DM_SPI=y
+CONFIG_DM_SPI_FLASH=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_STMICRO=y
+CONFIG_CMD_SF=y
+CONFIG_SF_DEFAULT_BUS=0
+CONFIG_SF_DEFAULT_CS=0
+CONFIG_SF_DEFAULT_SPEED=40000000
+CONFIG_SF_DEFAULT_MODE=0
+
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_XHCI_IMX8=y
+CONFIG_DM_USB=y
+CONFIG_DM_USB_GADGET=y
+CONFIG_SPL_DM_USB_GADGET=y
+CONFIG_USB=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_USB_GADGET_MANUFACTURER="FSL"
+CONFIG_USB_GADGET_VENDOR_NUM=0x0525
+CONFIG_USB_GADGET_PRODUCT_NUM=0xa4a5
+CONFIG_USB_CDNS3=y
+CONFIG_USB_CDNS3_GADGET=y
+CONFIG_USB_GADGET_DUALSPEED=y
+CONFIG_CDNS3_USB_PHY=y
+CONFIG_PHY=y
+CONFIG_SPL_PHY=y
+CONFIG_USB_STORAGE=y
+
+CONFIG_SPL_USB_GADGET=y
+CONFIG_SPL_USB_SDP_SUPPORT=y
+CONFIG_SPL_SDP_USB_DEV=1
+CONFIG_SDP_LOADADDR=0x80400000
+
+CONFIG_FASTBOOT=y
+CONFIG_USB_FUNCTION_FASTBOOT=y
+CONFIG_CMD_FASTBOOT=y
+CONFIG_ANDROID_BOOT_IMAGE=y
+CONFIG_FASTBOOT_UUU_SUPPORT=y
+CONFIG_FASTBOOT_BUF_ADDR=0x82800000
+CONFIG_FASTBOOT_BUF_SIZE=0x40000000
+CONFIG_FASTBOOT_FLASH=y
+CONFIG_FASTBOOT_USB_DEV=1
+
+CONFIG_BOOTAUX_RESERVED_MEM_BASE=0x88000000
+CONFIG_BOOTAUX_RESERVED_MEM_SIZE=0x08000000
+
+CONFIG_REGMAP=y
+CONFIG_SYSCON=y
+CONFIG_AHCI=y
+CONFIG_IMX_AHCI=y
+CONFIG_DM_SCSI=y
+CONFIG_SCSI=y
+CONFIG_CMD_SCSI=y
+
+CONFIG_PCI=y
+CONFIG_DM_PCI=y
+
+CONFIG_USB_PORT_AUTO=y
+CONFIG_USB_HOST_ETHER=y
+CONFIG_USB_ETHER_ASIX=y
+CONFIG_USB_ETHER_ASIX88179=y
+CONFIG_USB_ETHER_LAN75XX=y
+CONFIG_USB_ETHER_LAN78XX=y
+CONFIG_USB_ETHER_MCS7830=y
+CONFIG_USB_ETHER_SMSC95XX=y
+
+CONFIG_SNVS_SEC_SC=y
+
+CONFIG_VIDEO_IMX_HDP_LOAD=y
+CONFIG_OF_LIBFDT_OVERLAY=y
+
+CONFIG_VIDEO_IMXDPUV1=y
+CONFIG_DM_VIDEO=y
+CONFIG_VIDEO_IMX8_LVDS=y
+CONFIG_VIDEO_IT6263_BRIDGE=y
+CONFIG_SYS_WHITE_ON_BLACK=y
diff --git a/include/configs/cl-som-imx8max.h b/include/configs/cl-som-imx8max.h
new file mode 100644
index 0000000000..bc5b385c4e
--- /dev/null
+++ b/include/configs/cl-som-imx8max.h
@@ -0,0 +1,375 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright 2020 Compulab
+ */
+
+#ifndef __CL_SOM_IMX8MAX_H
+#define __CL_SOM_IMX8MAX_H
+
+#include <linux/sizes.h>
+#include <asm/arch/imx-regs.h>
+#include "imx_env.h"
+
+#ifdef CONFIG_SPL_BUILD
+#define CONFIG_SPL_MAX_SIZE				(192 * 1024)
+#define CONFIG_SYS_MONITOR_LEN				(1024 * 1024)
+#define CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_USE_SECTOR
+#define CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR                0x1040 /* (flash.bin_offset + 2Mb)/sector_size */
+
+/*
+ * 0x08081000 - 0x08180FFF is for m4_0 xip image,
+ * 0x08181000 - 0x008280FFF is for m4_1 xip image
+  * So 3rd container image may start from 0x8281000
+ */
+#define CONFIG_SYS_UBOOT_BASE 0x08281000
+#define CONFIG_SYS_MMCSD_FS_BOOT_PARTITION             0
+
+#define CONFIG_SPL_LDSCRIPT		"arch/arm/cpu/armv8/u-boot-spl.lds"
+#define CONFIG_SPL_STACK		0x013fff0
+#define CONFIG_SPL_BSS_START_ADDR      0x00130000
+#define CONFIG_SPL_BSS_MAX_SIZE		0x1000	/* 4 KB */
+#define CONFIG_SYS_SPL_MALLOC_START	0x82200000
+#define CONFIG_SYS_SPL_MALLOC_SIZE     0x80000	/* 512 KB */
+#define CONFIG_SERIAL_LPUART_BASE	0x5a060000
+#define CONFIG_MALLOC_F_ADDR		0x00138000
+
+#define CONFIG_SPL_RAW_IMAGE_ARM_TRUSTED_FIRMWARE
+
+#define CONFIG_SPL_ABORT_ON_RAW_IMAGE
+
+#define CONFIG_OF_EMBED
+#endif
+
+#define CONFIG_REMAKE_ELF
+
+#define CONFIG_BOARD_EARLY_INIT_F
+
+#define CONFIG_CMD_READ
+
+/* Flat Device Tree Definitions */
+#define CONFIG_OF_BOARD_SETUP
+
+#undef CONFIG_CMD_EXPORTENV
+#undef CONFIG_CMD_IMPORTENV
+#undef CONFIG_CMD_IMLS
+
+#undef CONFIG_CMD_CRC32
+
+#define CONFIG_SYS_FSL_ESDHC_ADDR       0
+#define USDHC1_BASE_ADDR                0x5B010000
+#define USDHC2_BASE_ADDR                0x5B020000
+#define USDHC3_BASE_ADDR                0x5B030000
+
+#define CONFIG_ENV_OVERWRITE
+
+#define CONFIG_PCIE_IMX
+#define CONFIG_CMD_PCI
+#define CONFIG_PCI_SCAN_SHOW
+
+#define CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG
+
+#define CONFIG_FEC_XCV_TYPE             RGMII
+#define FEC_QUIRK_ENET_MAC
+#define PHY_ANEG_TIMEOUT 20000
+
+/* ENET0 connects AR8031 on CPU board, ENET1 connects to base board */
+#define CONFIG_FEC_ENET_DEV 0
+
+#if (CONFIG_FEC_ENET_DEV == 0)
+#define IMX_FEC_BASE			0x5B040000
+#define CONFIG_FEC_MXC_PHYADDR          0x0
+#define CONFIG_ETHPRIME                 "eth0"
+#elif (CONFIG_FEC_ENET_DEV == 1)
+#define IMX_FEC_BASE			0x5B050000
+#define CONFIG_FEC_MXC_PHYADDR          0x1
+#define CONFIG_ETHPRIME                 "eth1"
+#endif
+
+#ifdef CONFIG_AHAB_BOOT
+#define AHAB_ENV "sec_boot=yes\0"
+#else
+#define AHAB_ENV "sec_boot=no\0"
+#endif
+
+
+#define JAILHOUSE_ENV \
+	"jh_mmcboot=" \
+		"setenv fdt_file imx8qm-mek-root.dtb;"\
+		"setenv boot_os 'scu_rm dtb ${fdt_addr}; booti ${loadaddr} - ${fdt_addr};'; " \
+		"run mmcboot; \0" \
+	"jh_netboot=" \
+		"setenv fdt_file imx8qm-mek-root.dtb;"\
+		"setenv boot_os 'scu_rm dtb ${fdt_addr}; booti ${loadaddr} - ${fdt_addr};'; " \
+		"run netboot; \0"
+
+#define XEN_BOOT_ENV \
+	    "domu-android-auto=no\0" \
+            "xenhyper_bootargs=console=dtuart dom0_mem=2048M dom0_max_vcpus=2 dom0_vcpus_pin=true hmp-unsafe=true\0" \
+            "xenlinux_bootargs= \0" \
+            "xenlinux_console=hvc0 earlycon=xen\0" \
+            "xenlinux_addr=0x9e000000\0" \
+	    "dom0fdt_file=imx8qm-mek-dom0.dtb\0" \
+            "xenboot_common=" \
+                "${get_cmd} ${loadaddr} xen;" \
+                "${get_cmd} ${fdt_addr} ${dom0fdt_file};" \
+                "if ${get_cmd} ${hdp_addr} ${hdp_file}; then; hdp load ${hdp_addr}; fi;" \
+                "${get_cmd} ${xenlinux_addr} ${image};" \
+                "fdt addr ${fdt_addr};" \
+                "fdt resize 256;" \
+                "fdt set /chosen/module@0 reg <0x00000000 ${xenlinux_addr} 0x00000000 0x${filesize}>; " \
+                "fdt set /chosen/module@0 bootargs \"${bootargs} ${xenlinux_bootargs}\"; " \
+		"if test ${domu-android-auto} = yes; then; " \
+			"fdt set /domu/doma android-auto <1>;" \
+			"fdt rm /gpio@5d090000 power-domains;" \
+		"fi;" \
+                "setenv bootargs ${xenhyper_bootargs};" \
+                "booti ${loadaddr} - ${fdt_addr};" \
+            "\0" \
+            "xennetboot=" \
+                "setenv get_cmd dhcp;" \
+                "setenv console ${xenlinux_console};" \
+                "run netargs;" \
+                "run xenboot_common;" \
+            "\0" \
+            "xenmmcboot=" \
+                "setenv get_cmd \"fatload mmc ${mmcdev}:${mmcpart}\";" \
+                "setenv console ${xenlinux_console};" \
+                "run mmcargs;" \
+                "run xenboot_common;" \
+            "\0" \
+/* Boot M4 */
+#define M4_BOOT_ENV \
+	"m4_0_image=m4_0.bin\0" \
+	"m4_1_image=m4_1.bin\0" \
+	"loadm4image_0=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${m4_0_image}\0" \
+	"loadm4image_1=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${m4_1_image}\0" \
+	"m4boot_0=run loadm4image_0; dcache flush; bootaux ${loadaddr} 0\0" \
+	"m4boot_1=run loadm4image_1; dcache flush; bootaux ${loadaddr} 1\0" \
+
+#ifdef CONFIG_NAND_BOOT
+#define MFG_NAND_PARTITION "mtdparts=gpmi-nand:128m(boot),32m(kernel),16m(dtb),8m(misc),-(rootfs) "
+#else
+#define MFG_NAND_PARTITION ""
+#endif
+
+#define CONFIG_MFG_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS_DEFAULT \
+	"initrd_addr=0x83100000\0" \
+	"initrd_high=0xffffffffffffffff\0" \
+	"emmc_dev=0\0" \
+	"sd_dev=1\0" \
+
+/* Initial environment variables */
+#define CONFIG_EXTRA_ENV_SETTINGS		\
+	CONFIG_MFG_ENV_SETTINGS \
+	M4_BOOT_ENV \
+	XEN_BOOT_ENV \
+	JAILHOUSE_ENV\
+	AHAB_ENV \
+	"script=boot.scr\0" \
+	"image=Image\0" \
+	"splashimage=0x9e000000\0" \
+	"console=ttyLP0\0" \
+	"fdt_addr=0x83000000\0"			\
+	"fdt_high=0xffffffffffffffff\0"		\
+	"cntr_addr=0x98000000\0"			\
+	"cntr_file=os_cntr_signed.bin\0" \
+	"boot_fdt=try\0" \
+	"fdt_file=" CONFIG_DEFAULT_FDT_FILE "\0" \
+	"mmcdev="__stringify(CONFIG_SYS_MMC_ENV_DEV)"\0" \
+	"mmcpart=" __stringify(CONFIG_SYS_MMC_IMG_LOAD_PART) "\0" \
+	"mmcroot=" CONFIG_MMCROOT " rootwait rw\0" \
+	"mmcautodetect=yes\0" \
+	"mmcargs=setenv bootargs console=${console},${baudrate} earlycon root=${mmcroot}\0 " \
+	"loadbootscript=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${script};\0" \
+	"bootscript=echo Running bootscript from mmc ...; " \
+		"source\0" \
+	"loadimage=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${image}\0" \
+	"loadfdt=fatload mmc ${mmcdev}:${mmcpart} ${fdt_addr} ${fdt_file}\0" \
+	"hdp_addr=0x9c000000\0" \
+	"hdprx_addr=0x9c800000\0" \
+	"hdp_file=hdmitxfw.bin\0" \
+	"hdprx_file=hdmirxfw.bin\0" \
+	"loadhdp=fatload mmc ${mmcdev}:${mmcpart} ${hdp_addr} ${hdp_file}\0" \
+	"loadhdprx=fatload mmc ${mmcdev}:${mmcpart} ${hdprx_addr} ${hdprx_file}\0" \
+	"boot_os=booti ${loadaddr} - ${fdt_addr};\0" \
+	"loadcntr=fatload mmc ${mmcdev}:${mmcpart} ${cntr_addr} ${cntr_file}\0" \
+	"auth_os=auth_cntr ${cntr_addr}\0" \
+	"mmcboot=echo Booting from mmc ...; " \
+		"if run loadhdp; then; hdp load ${hdp_addr}; fi;" \
+		"run mmcargs; " \
+		"if test ${sec_boot} = yes; then " \
+			"if run auth_os; then " \
+				"run boot_os; " \
+			"else " \
+				"echo ERR: failed to authenticate; " \
+			"fi; " \
+		"else " \
+			"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+				"if run loadfdt; then " \
+					"run boot_os; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"else " \
+				"echo wait for boot; " \
+			"fi;" \
+		"fi;\0" \
+	"netargs=setenv bootargs console=${console},${baudrate} earlycon " \
+		"root=/dev/nfs " \
+		"ip=dhcp nfsroot=${serverip}:${nfsroot},v3,tcp\0" \
+	"netboot=echo Booting from net ...; " \
+		"run netargs;  " \
+		"if test ${ip_dyn} = yes; then " \
+			"setenv get_cmd dhcp; " \
+		"else " \
+			"setenv get_cmd tftp; " \
+		"fi; " \
+		"if ${get_cmd} ${hdp_addr} ${hdp_file}; then; hdp load ${hdp_addr}; fi;" \
+		"if test ${sec_boot} = yes; then " \
+			"${get_cmd} ${cntr_addr} ${cntr_file}; " \
+			"if run auth_os; then " \
+				"run boot_os; " \
+			"else " \
+				"echo ERR: failed to authenticate; " \
+			"fi; " \
+		"else " \
+			"${get_cmd} ${loadaddr} ${image}; " \
+			"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+				"if ${get_cmd} ${fdt_addr} ${fdt_file}; then " \
+					"run boot_os; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"else " \
+				"booti; " \
+			"fi;" \
+		"fi;\0"
+
+#define CONFIG_BOOTCOMMAND \
+	   "mmc dev ${mmcdev}; if mmc rescan; then " \
+		   "if run loadbootscript; then " \
+			   "run bootscript; " \
+		   "else " \
+			   "if test ${sec_boot} = yes; then " \
+				   "if run loadcntr; then " \
+					   "run mmcboot; " \
+				   "else run netboot; " \
+				   "fi; " \
+			    "else " \
+				   "if run loadimage; then " \
+					   "run mmcboot; " \
+				   "else run netboot; " \
+				   "fi; " \
+			 "fi; " \
+		   "fi; " \
+	   "else booti ${loadaddr} - ${fdt_addr}; fi"
+
+/* Link Definitions */
+#define CONFIG_LOADADDR			0x80280000
+
+#define CONFIG_SYS_LOAD_ADDR           CONFIG_LOADADDR
+
+#define CONFIG_SYS_INIT_SP_ADDR         0x80200000
+
+
+#ifdef CONFIG_QSPI_BOOT
+#define CONFIG_ENV_SECT_SIZE	(128 * 1024)
+#define CONFIG_ENV_SPI_BUS	CONFIG_SF_DEFAULT_BUS
+#define CONFIG_ENV_SPI_CS	CONFIG_SF_DEFAULT_CS
+#define CONFIG_ENV_SPI_MODE	CONFIG_SF_DEFAULT_MODE
+#define CONFIG_ENV_SPI_MAX_HZ	CONFIG_SF_DEFAULT_SPEED
+#else
+#define CONFIG_SYS_MMC_ENV_PART		0	/* user area */
+#endif
+
+#define CONFIG_SYS_MMC_IMG_LOAD_PART	1
+
+/* On LPDDR4 board, USDHC1 is for eMMC, USDHC2 is for SD on CPU board */
+#define CONFIG_SYS_MMC_ENV_DEV		1   /* USDHC2 */
+#define CONFIG_MMCROOT			"/dev/mmcblk1p2"  /* USDHC2 */
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		((CONFIG_ENV_SIZE + (32 * 1024)) * 1024)
+
+#define CONFIG_SYS_SDRAM_BASE		0x80000000
+#define PHYS_SDRAM_1			0x80000000
+#define PHYS_SDRAM_1_SIZE		(SZ_2G)		/* 2 GB */
+#define PHYS_SDRAM_2			0x880000000
+#define PHYS_SDRAM_2_SIZE		(SZ_2G)		/* 6 GB */
+
+#define CONFIG_SYS_MEMTEST_START    0xA0000000
+#define CONFIG_SYS_MEMTEST_END      (CONFIG_SYS_MEMTEST_START + (PHYS_SDRAM_1_SIZE >> 2))
+
+/* Serial */
+#define CONFIG_BAUDRATE			115200
+
+/* Monitor Command Prompt */
+#define CONFIG_SYS_PROMPT_HUSH_PS2     "> "
+#define CONFIG_SYS_CBSIZE              2048
+#define CONFIG_SYS_MAXARGS             64
+#define CONFIG_SYS_BARGSIZE CONFIG_SYS_CBSIZE
+#define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + \
+					sizeof(CONFIG_SYS_PROMPT) + 16)
+
+/* Generic Timer Definitions */
+#define COUNTER_FREQUENCY		8000000	/* 8MHz */
+
+#ifndef CONFIG_DM_PCA953X
+#define CONFIG_PCA953X
+#define CONFIG_CMD_PCA953X
+#define CONFIG_CMD_PCA953X_INFO
+#endif
+
+/* MT35XU512ABA1G12 has only one Die, so QSPI0 B won't work */
+#ifdef CONFIG_FSL_FSPI
+#define FSL_FSPI_FLASH_SIZE		SZ_64M
+#define FSL_FSPI_FLASH_NUM		1
+#define FSPI0_BASE_ADDR			0x5d120000
+#define FSPI0_AMBA_BASE			0
+#define CONFIG_SYS_FSL_FSPI_AHB
+#endif
+
+#define CONFIG_SERIAL_TAG
+
+/* USB Config */
+#ifndef CONFIG_SPL_BUILD
+/*#define CONFIG_CMD_USB*/
+/*#define CONFIG_USB_STORAGE*/
+#define CONFIG_USBD_HS
+
+/*
+#define CONFIG_CMD_USB_MASS_STORAGE
+#define CONFIG_USB_GADGET_MASS_STORAGE
+#define CONFIG_USB_FUNCTION_MASS_STORAGE
+*/
+
+#endif
+
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+
+/* USB OTG controller configs */
+#ifdef CONFIG_USB_EHCI_HCD
+#define CONFIG_MXC_USB_PORTSC		(PORT_PTS_UTMI | PORT_PTS_PTW)
+#endif
+
+#ifdef CONFIG_DM_VIDEO
+#define CONFIG_VIDEO_LOGO
+#define CONFIG_SPLASH_SCREEN
+#define CONFIG_SPLASH_SCREEN_ALIGN
+#define CONFIG_CMD_BMP
+#define CONFIG_BMP_16BPP
+#define CONFIG_BMP_24BPP
+#define CONFIG_BMP_32BPP
+#define CONFIG_VIDEO_BMP_RLE8
+#define CONFIG_VIDEO_BMP_LOGO
+#endif
+
+#if defined(CONFIG_ANDROID_SUPPORT)
+#include "imx8qm_mek_android.h"
+#elif defined (CONFIG_ANDROID_AUTO_SUPPORT)
+#include "imx8qm_mek_android_auto.h"
+#endif
+
+#endif /* __CL_SOM_IMX8MAX_H */
diff --git a/include/linux/sizes.h b/include/linux/sizes.h
index fbde0bc7e8..b059566af8 100644
--- a/include/linux/sizes.h
+++ b/include/linux/sizes.h
@@ -47,5 +47,7 @@
 #define SZ_2G				0x80000000
 
 #define SZ_4G				_AC(0x100000000, ULL)
+#define SZ_6G				_AC(0x180000000, ULL)
+#define SZ_8G				_AC(0x200000000, ULL)
 
 #endif /* __LINUX_SIZES_H__ */
-- 
2.20.1

